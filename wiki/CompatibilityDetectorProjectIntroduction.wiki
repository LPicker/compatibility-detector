= 项目历史 =

compatibility-detector 项目最初由 Google Chrome Team 的高级工程师 *丁建宁* 发起， *2010年初*，首先由他尝试开发了最初版本的检测工具，以及最初版本的 framework 检测框架。其后陆续有其他 Google 工程师参与该项目。 高级工程师*王显著* 继 *丁建宁* 后重构了 framework 检测框架，使他具备了更为完善的功能；工程师 *罗宇翔* 和他们一起提供了最初的一些检测算法代码，使这个工具可以正常工作。
在此基础上，Google 的工程师们又定制了一版特殊的 Chrome 浏览器，使它可以自动运行检测内容，汇总出指定Web页面中的问题，并发送相应的检测报告，这些工程师包括*黄浩*以及*汪峰*和之前提到的工程师们。

在此期间，*W3Help的分析小组*正在立志于从国内站点中收集常见的兼容性检测问题，将他们汇总分析以及撰写根源问题分析文章，这就是W3Help站点内最初文章内容的来源，同时也是 compatibility-detector 工具检测出问题后的说明数据支持。

W3Help内容充沛后，*2010年10月*，分析小组开始逐步接手之前 Google 工程师的工作，全力参与到 compatibility-detector 的开发进程中。在这期间，完成了对 *framework 检测框架的进一步完善与丰富*；陆续*攻克若干项检测准确度难题*；*重构之前有问题的若干检测算法*；*完成新的检测内容*；为检测工具*加入基本检测*、*检测报告汇总*、*选项页*等若干任务内容。

在*2011年5月初*，这个*项目正式开源*，*5月底*，W3Help站点原创文章内容也被加入到开源项目中来。*到此为止所有感兴趣的开发者均能自由的加入到此项目中来，可以采用提交检测算法代码，修正检测框架，编写兼容问题分析文章等方式，来为浏览器发展以及前端事业尽一份绵薄之力*。

= 项目文件结构 =

compatibility-detector 项目拥有如下目录结构：
  *\release 目录用来存放发布版本的源码，它通过定期从src目录 marge 获得；
  *\src 目录用来存放compatibility-detector项目主干版本源码（基于主干开发）；
    * _locales 目录为 i18n 信息存放目录，分别保存中文以及英文内容的 messsage.json 文件；
    * detectors 目录存放所有检测项目的算法文件，大部分情况下，每个算法文件为一个js文件，各别文件内存在多个简单的检测算法；
    * manifest.json 文件用来配置 detector 项目要检测的内容，这个文件是 Chrome Extensions 机制所要求的；
    * loader.js 文件用来向页面注入检测代码以及建立页面脚本与Content Script之间基于DOM事件的通信机制；
    * framework.js 为检测主框架代码，除实现必要的检测逻辑之外，还拥有大量的helper函数来辅助开发；
    * framework_shared.js 作为框架辅助代码，只为实现页面脚本与Content Script之间共有内容而存在，它的作用是将同一脚本分别复制到页面与Content Script内运行，使两者都能使用同一共有数据结果或helper函数；
    * w3help_issues.js 文件定义了w3help内根本原因的编号，用来配合检测内容定位相关错误；
    * annotation.js 文件用来在页面显示错误气泡提示；
    * config.js 文件用来配置项目相关细节，如最大错误气泡显示数量等；
    * constants.js 文件内是公用常量定义；
    * base_detection.js 文件用来做基本检测相关内容；
    * options.html 选项页面
    * popup.html 基本检测以及高级检测页面
    * helper.js 相关页面文件所需要使用的公用函数
    * background.html 扩展后端进程页面
  *\tests 目录用来存放compatibility-detector项目中，每个检测算法(detector)相关的测试用例；
  *\tools 目录用来存放相关工具，如w3help内容页面的build工具；
  *\w3help 目录用来存放w3help的相关文章内容

= 检测框架说明 =
framework.js 实现了整体检测框架，提供了三种基本检测方式：
  # chrome_comp.CompDetect.NonScanDomBaseDetector
  # chrome_comp.CompDetect.ScanDomBaseDetector
  # chrome_comp.CompDetect.registerExistingMethodHook 和 chrome_comp.CompDetect.registerExistingPropertyHook

*NonScanDomBaseDetector* 可以自己实现扫描节点机制，用来记录相关节点信息与其他节点比较。例如，检测某些节点是否在渲染时存在布局块重叠情况。

*ScanDomBaseDetector* 采用框架提供的扫描节点机制，每扫描一个节点均会调用 *checkNode* 方法，检测算法可以再此方法内执行。例如，检测某些节点自身布局情况或自身属性设置等。

无论 *NonScanDomBaseDetector* 或者 *ScanDomBaseDetector* 类，均有 *postAnalyze* 方法，此方法在所有检测代码执行完成后被统一调用。它可以用来做数据汇总或者检测内容补充修正等后续处理工作；当然，也可以配合 *NonScanDomBaseDetector* 机制实现当前检测算法自身的节点扫描分析机制。

*chrome_comp.CompDetect.registerExistingMethodHook* 与 *chrome_comp.CompDetect.registerExistingPropertyHook* 分别是 JS 脚本的钩子机制。他们分别负责*HOOK已存在的方法*和*HOOK不存在的属性*。当某方法或某属性的钩子被注册后，此方法调用时，会先调用注册的钩子程序，由钩子程序负责调用原始方法以、识别传入的实参、保存方法返回结果等内容，由开发者在钩子注册函数内实现这些内容的解析与分析。

*主要的检测模型图示*
http://img844.ph.126.net/0pFdck3OPF7nih2c-3tZGA==/1890385943590752722.jpg
http://img616.ph.126.net/8jNaDjM2N2jQlXFiVxU9Zw==/1989465135393179370.jpg
http://img.ph.126.net/CkGzdvRix97hL0Oscc_cyg==/3395151169085260845.jpg

= 脚本注入以及消息传递机制说明  =

* 消息传递模型图示 *
http://img616.ph.126.net/75PhJ8ad_2sKbsTiqQcrZw==/1989465135393179347.jpg